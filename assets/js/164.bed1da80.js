(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{754:function(e,r,v){"use strict";v.r(r);var a=v(2),t=Object(a.a)({},(function(){var e=this,r=e.$createElement,v=e._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"服务发现组件-eureka-的几个主要调用过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务发现组件-eureka-的几个主要调用过程"}},[e._v("#")]),e._v(" 服务发现组件 Eureka 的几个主要调用过程")]),e._v(" "),v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),v("p",[e._v("现在流行的微服务体系结构正在改变我们构建应用程序的方式，从单一的单体服务转变为越来越小的可单独部署的服务（称为 "),v("code",[e._v("微服务")]),e._v(" ），共同构成了我们的应用程序。当进行一个业务时不可避免就会存在多个服务之间调用，假如一个服务 A 要访问在另一台服务器部署的服务 B，那么前提是服务 A 要知道服务 B 所在机器的 IP 地址和服务对应的端口，最简单的方式就是让服务 A 自己去维护一份服务 B 的配置（包含 IP 地址和端口等信息），但是这种方式有几个明显的缺点：随着我们调用服务数量的增加，配置文件该如何维护；缺乏灵活性，如果服务 B 改变 IP 地址或者端口，服务 A 也要修改相应的文件配置；还有一个就是进行服务的动态扩容或缩小不方便。\n一个比较好的解决方案就是 "),v("code",[e._v("服务发现（Service Discovery）")]),e._v(" 。它抽象出来了一个注册中心，当一个新的服务上线时，它会将自己的 IP 和端口注册到注册中心去，会对注册的服务进行定期的心跳检测，当发现服务状态异常时将其从注册中心剔除下线。服务 A 只要从注册中心中获取服务 B 的信息即可，即使当服务 B 的 IP 或者端口变更了，服务 A 也无需修改，从一定程度上解耦了服务。服务发现目前业界有很多开源的实现，比如 "),v("code",[e._v("apache")]),e._v(" 的 "),v("a",{attrs:{href:"https://github.com/apache/zookeeper",target:"_blank",rel:"noopener noreferrer"}},[e._v("zookeeper"),v("OutboundLink")],1),e._v("、 "),v("code",[e._v("Netflix")]),e._v(" 的 "),v("a",{attrs:{href:"https://github.com/Netflix/eureka",target:"_blank",rel:"noopener noreferrer"}},[e._v("eureka"),v("OutboundLink")],1),e._v("、 "),v("code",[e._v("hashicorp")]),e._v(" 的 "),v("a",{attrs:{href:"https://github.com/hashicorp/consul",target:"_blank",rel:"noopener noreferrer"}},[e._v("consul"),v("OutboundLink")],1),e._v("、 "),v("code",[e._v("CoreOS")]),e._v(" 的 "),v("a",{attrs:{href:"https://github.com/etcd-io/etcd",target:"_blank",rel:"noopener noreferrer"}},[e._v("etcd"),v("OutboundLink")],1),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"eureka-是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eureka-是什么"}},[e._v("#")]),e._v(" Eureka 是什么")]),e._v(" "),v("p",[v("code",[e._v("Eureka")]),e._v(" 在 "),v("a",{attrs:{href:"https://github.com/Netflix/eureka",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitHub"),v("OutboundLink")],1),e._v(" 上对其的定义为")]),e._v(" "),v("blockquote",[v("p",[e._v("Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers.")])]),e._v(" "),v("p",[e._v("At Netflix, Eureka is used for the following purposes apart from playing a critical part in mid-tier load balancing.")]),e._v(" "),v("p",[v("code",[e._v("Eureka")]),e._v(" 是由 "),v("a",{attrs:{href:"https://www.netflix.com",target:"_blank",rel:"noopener noreferrer"}},[e._v("Netflix"),v("OutboundLink")],1),e._v(" 公司开源，采用的是 Client / Server 模式进行设计，基于 http 协议和使用 Restful Api 开发的服务注册与发现组件，提供了完整的服务注册和服务发现，可以和 "),v("code",[e._v("Spring Cloud")]),e._v(" 无缝集成。其中 Server 端扮演着服务注册中心的角色，主要是为 Client 端提供服务注册和发现等功能，维护着 Client 端的服务注册信息，同时定期心跳检测已注册的服务当不可用时将服务剔除下线，Client 端可以通过 Server 端获取自身所依赖服务的注册信息，从而完成服务间的调用。遗憾的是从其官方的 "),v("a",{attrs:{href:"https://github.com/Netflix/eureka/wik",target:"_blank",rel:"noopener noreferrer"}},[e._v("github wiki"),v("OutboundLink")],1),e._v(" 可以发现，2.0 版本已经不再开源。但是不影响我们对其进行深入了解，毕竟服务注册、服务发现相对来说还是比较基础和通用的，其它开源实现框架的思想也是想通的。")]),e._v(" "),v("h2",{attrs:{id:"服务注册中心-eureka-server"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务注册中心-eureka-server"}},[e._v("#")]),e._v(" 服务注册中心（Eureka Server）")]),e._v(" "),v("p",[e._v("我们在项目中引入 "),v("code",[e._v("Eureka Server")]),e._v(" 的相关依赖，然后在启动类加上注解 "),v("code",[e._v("@EnableEurekaServer")]),e._v(" ，就可以将其作为注册中心，启动服务后访问页面如下：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-server-homepage.png",alt:"eureka-server-homepage.png"}})]),e._v(" "),v("p",[e._v("我们继续添加两个模块 "),v("code",[e._v("service-provider")]),e._v(" ， "),v("code",[e._v("service-consumer")]),e._v(" ，然后在启动类加上注解 "),v("code",[e._v("@EnableEurekaClient")]),e._v(" 并指定注册中心地址为我们刚刚启动的 "),v("code",[e._v("Eureka Server")]),e._v(" ，再次访问可以看到两个服务都已经注册进来了。")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-instance-registered-currently.png",alt:"eureka-instance-registered-currently.png"}})]),e._v(" "),v("p",[e._v("可以看到 "),v("code",[e._v("Eureka")]),e._v(" 的使用非常简单，只需要添加几个注解和配置就实现了服务注册和服务发现，接下来我们看看它是如何实现这些功能的。")]),e._v(" "),v("h3",{attrs:{id:"服务注册-register"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务注册-register"}},[e._v("#")]),e._v(" 服务注册（Register）")]),e._v(" "),v("p",[e._v("注册中心提供了服务注册接口，用于当有新的服务启动后进行调用来实现服务注册，或者心跳检测到服务状态异常时，变更对应服务的状态。服务注册就是发送一个 "),v("code",[e._v("POST")]),e._v(" 请求带上当前实例信息到类 "),v("code",[e._v("ApplicationResource")]),e._v(" 的 "),v("code",[e._v("addInstance")]),e._v(" 方法进行服务注册。")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-server-applicationresource-addinstance.png",alt:"eureka-server-applicationresource-addinstance.png"}})]),e._v(" "),v("p",[e._v("可以看到方法调用了类 "),v("code",[e._v("PeerAwareInstanceRegistryImpl")]),e._v(" 的 "),v("code",[e._v("register")]),e._v(" 方法，该方法主要分为两步：")]),e._v(" "),v("ol",[v("li",[e._v("调用父类 "),v("code",[e._v("AbstractInstanceRegistry")]),e._v(" 的 "),v("code",[e._v("register")]),e._v(" 方法把当前服务注册到注册中心")]),e._v(" "),v("li",[e._v("调用 "),v("code",[e._v("replicateToPeers")]),e._v(" 方法使用异步的方式向其它的 "),v("code",[e._v("Eureka Server")]),e._v(" 节点同步服务注册信息")])]),e._v(" "),v("p",[e._v("服务注册信息保存在一个嵌套的 "),v("code",[e._v("map")]),e._v(" 中，它的结构如下：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-server-registry-structure.png",alt:"eureka-server-registry-structure.png"}})]),e._v(" "),v("p",[e._v("第一层 "),v("code",[e._v("map")]),e._v(" 的 "),v("code",[e._v("key")]),e._v(" 是应用名称（对应 "),v("code",[e._v("Demo")]),e._v(" 里的 "),v("code",[e._v("SERVICE-PROVIDER")]),e._v(" ），第二层 "),v("code",[e._v("map")]),e._v(" 的 "),v("code",[e._v("key")]),e._v(" 是应用对应的实例名称（对应 "),v("code",[e._v("Demo")]),e._v(" 里的 "),v("code",[e._v("mghio-mbp:service-provider:9999")]),e._v(" ），一个应用可以有多个实例，主要调用流程如下图所示：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-server-register-sequence-chart.png",alt:"eureka-server-register-sequence-chart.png"}})]),e._v(" "),v("h3",{attrs:{id:"服务续约-renew"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务续约-renew"}},[e._v("#")]),e._v(" 服务续约（Renew）")]),e._v(" "),v("p",[e._v("服务续约会由服务提供者（比如 "),v("code",[e._v("Demo")]),e._v(" 中的 "),v("code",[e._v("service-provider")]),e._v(" ）定期调用，类似于心跳，用来告知注册中心 "),v("code",[e._v("Eureka Server")]),e._v(" 自己的状态，避免被 "),v("code",[e._v("Eureka Server")]),e._v(" 认为服务时效将其剔除下线。服务续约就是发送一个 "),v("code",[e._v("PUT")]),e._v(" 请求带上当前实例信息到类 "),v("code",[e._v("InstanceResource")]),e._v(" 的 "),v("code",[e._v("renewLease")]),e._v(" 方法进行服务续约操作。")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-server-instanceresource-renew.png",alt:"eureka-server-instanceresource-renew.png"}})]),e._v(" "),v("p",[e._v("进入到 "),v("code",[e._v("PeerAwareInstanceRegistryImpl")]),e._v(" 的 "),v("code",[e._v("renew")]),e._v(" 方法可以看到，服务续约步骤大体上和服务注册一致，先更新当前 "),v("code",[e._v("Eureka Server")]),e._v(" 节点的状态，服务续约成功后再用异步的方式同步状态到其它 "),v("code",[e._v("Eureka Server")]),e._v(" 节上，主要调用流程如下图所示：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-server-renew-sequence-chart.png",alt:"eureka-server-renew-sequence-chart.png"}})]),e._v(" "),v("h3",{attrs:{id:"服务下线-cancel"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务下线-cancel"}},[e._v("#")]),e._v(" 服务下线（Cancel）")]),e._v(" "),v("p",[e._v("当服务提供者（比如 "),v("code",[e._v("Demo")]),e._v(" 中的 "),v("code",[e._v("service-provider")]),e._v(" ）停止服务时，会发送请求告知注册中心 "),v("code",[e._v("Eureka Server")]),e._v(" 进行服务剔除下线操作，防止服务消费者从注册中心调用到不存在的服务。服务下线就是发送一个 "),v("code",[e._v("DELETE")]),e._v(" 请求带上当前实例信息到类 "),v("code",[e._v("InstanceResource")]),e._v(" 的 "),v("code",[e._v("cancelLease")]),e._v(" 方法进行服务剔除下线操作。")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-server-instanceresource-cancellease.png",alt:"eureka-server-instanceresource-cancellease.png"}})]),e._v(" "),v("p",[e._v("进入到 "),v("code",[e._v("PeerAwareInstanceRegistryImpl")]),e._v(" 的 "),v("code",[e._v("cancel")]),e._v(" 方法可以看到，服务续约步骤大体上和服务注册一致，先在当前 "),v("code",[e._v("Eureka Server")]),e._v(" 节点剔除下线该服务，服务下线成功后再用异步的方式同步状态到其它 "),v("code",[e._v("Eureka Server")]),e._v(" 节上，主要调用流程如下图所示：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-server-cancellease-sequence-chart.png",alt:"eureka-server-cancellease-sequence-chart.png"}})]),e._v(" "),v("h3",{attrs:{id:"服务剔除-eviction"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务剔除-eviction"}},[e._v("#")]),e._v(" 服务剔除（Eviction）")]),e._v(" "),v("p",[e._v("服务剔除是注册中心 "),v("code",[e._v("Eureka Server")]),e._v(" 在启动时就启动一个守护线程 "),v("code",[e._v("evictionTimer")]),e._v(" 来定期（默认为 "),v("code",[e._v("60")]),e._v(" 秒）执行检测服务的，判断标准就是超过一定时间没有进行 "),v("code",[e._v("Renew")]),e._v(" 的服务，默认的失效时间是 "),v("code",[e._v("90")]),e._v(" 秒，也就是说当一个已注册的服务在 "),v("code",[e._v("90")]),e._v(" 秒内没有向注册中心 "),v("code",[e._v("Eureka Server")]),e._v(" 进行服务续约（Renew），就会被从注册中心剔除下线。失效时间可以通过配置 "),v("code",[e._v("eureka.instance.leaseExpirationDurationInSeconds")]),e._v(" 进行修改，定期执行检测服务可以通过配置 "),v("code",[e._v("eureka.server.evictionIntervalTimerInMs")]),e._v(" 进行修改，主要调用流程如下图所示：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-server-evict-sequence-chart.png",alt:"eureka-server-evict-sequence-chart.png"}})]),e._v(" "),v("h2",{attrs:{id:"服务提供者-service-provider"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务提供者-service-provider"}},[e._v("#")]),e._v(" 服务提供者（Service Provider）")]),e._v(" "),v("p",[e._v("对于服务提供方（比如 "),v("code",[e._v("Demo")]),e._v(" 中的 "),v("code",[e._v("service-provider")]),e._v(" 服务）来说，主要有三大类操作，分别为 "),v("code",[e._v("服务注册（Register）")]),e._v(" 、 "),v("code",[e._v("服务续约（Renew）")]),e._v(" 、 "),v("code",[e._v("服务下线（Cancel）")]),e._v(" ，接下来看看这三个操作是如何实现的。")]),e._v(" "),v("h3",{attrs:{id:"服务注册-register-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务注册-register-2"}},[e._v("#")]),e._v(" 服务注册（Register）")]),e._v(" "),v("p",[e._v("一个服务要对外提供服务，首先要在注册中心 "),v("code",[e._v("Eureka Server")]),e._v(" 进行服务相关信息注册，能进行这一步的前提是你要配置 "),v("code",[e._v("eureka.client.register-with-eureka=true")]),e._v(" ，这个默认值为 "),v("code",[e._v("true")]),e._v(" ，注册中心不需要把自己注册到注册中心去，把这个配置设为 "),v("code",[e._v("false")]),e._v(" ，这个调用比较简单，主要调用流程如下图所示：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-server-register-sequence-chart.png",alt:"eureka-service-provider-register-sequence-chart.png"}})]),e._v(" "),v("h3",{attrs:{id:"服务续约-renew-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务续约-renew-2"}},[e._v("#")]),e._v(" 服务续约（Renew）")]),e._v(" "),v("p",[e._v("服务续约是由服务提供者方定期（默认为 "),v("code",[e._v("30")]),e._v(" 秒）发起心跳的，主要是用来告知注册中心 "),v("code",[e._v("Eureka Server")]),e._v(" 自己状态是正常的还活着，可以通过配置 "),v("code",[e._v("eureka.instance.lease-renewal-interval-in-seconds")]),e._v(" 来修改，当然服务续约的前提是要配置 "),v("code",[e._v("eureka.client.register-with-eureka=true")]),e._v(" ，将该服务注册到注册中心中去，主要调用流程如下图所示：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-service-provider-renew-sequence-chart.png",alt:"eureka-service-provider-renew-sequence-chart.png"}})]),e._v(" "),v("h3",{attrs:{id:"服务下线-cancel-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务下线-cancel-2"}},[e._v("#")]),e._v(" 服务下线（Cancel）")]),e._v(" "),v("p",[e._v("当服务提供者方服务停止时，要发送 "),v("code",[e._v("DELETE")]),e._v(" 请求告知注册中心 "),v("code",[e._v("Eureka Server")]),e._v(" 自己已经下线，好让注册中心将自己剔除下线，防止服务消费方从注册中心获取到不可用的服务。这个过程实现比较简单，在类 "),v("code",[e._v("DiscoveryClient")]),e._v(" 的 "),v("code",[e._v("shutdown")]),e._v(" 方法加上注解 "),v("code",[e._v("@PreDestroy")]),e._v(" ，当服务停止时会自动触发服务剔除下线，执行服务下线逻辑，主要调用流程如下图所示：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-service-provider-cancel-sequence-chart.png",alt:"eureka-service-provider-cancel-sequence-chart.png"}})]),e._v(" "),v("h2",{attrs:{id:"服务消费者-service-consumer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务消费者-service-consumer"}},[e._v("#")]),e._v(" 服务消费者（Service Consumer）")]),e._v(" "),v("p",[e._v("这里的服务消费者如果不需要被其它服务调用的话，其实只会涉及到两个操作，分别是从注册中心 "),v("code",[e._v("获取服务列表（Fetch）")]),e._v(" 和 "),v("code",[e._v("更新服务列表（Update）")]),e._v(" 。如果同时也需要注册到注册中心对外提供服务的话，那么剩下的过程和上文提到的服务提供者是一致的，这里不再阐述，接下来看看这两个操作是如何实现的。")]),e._v(" "),v("h3",{attrs:{id:"获取服务列表-fetch"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#获取服务列表-fetch"}},[e._v("#")]),e._v(" 获取服务列表（Fetch）")]),e._v(" "),v("p",[e._v("服务消费者方启动之后首先肯定是要先从注册中心 "),v("code",[e._v("Eureka Server")]),e._v(" 获取到可用的服务列表同时本地也会缓存一份。这个获取服务列表的操作是在服务启动后 "),v("code",[e._v("DiscoverClient")]),e._v(" 类实例化的时候执行的。")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-service-consumer-fetchregistry.png",alt:"eureka-service-consumer-fetchregistry.png"}})]),e._v(" "),v("p",[e._v("可以看出，能发生这个获取服务列表的操作前提是要保证配置了 "),v("code",[e._v("eureka.client.fetch-registry=true")]),e._v(" ，该配置的默认值为 "),v("code",[e._v("true")]),e._v(" ，主要调用流程如下图所示：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-service-consumer-fetch-sequence-chart.png",alt:"eureka-service-consumer-fetch-sequence-chart.png"}})]),e._v(" "),v("h3",{attrs:{id:"更新服务列表-update"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#更新服务列表-update"}},[e._v("#")]),e._v(" 更新服务列表（Update）")]),e._v(" "),v("p",[e._v("由上面的 "),v("code",[e._v("获取服务列表（Fetch）")]),e._v(" 操作过程可知，本地也会缓存一份，所以这里需要定期的去到注册中心 "),v("code",[e._v("Eureka Server")]),e._v(" 获取服务的最新配置，然后比较更新本地缓存，这个更新的间隔时间可以通过配置 "),v("code",[e._v("eureka.client.registry-fetch-interval-seconds")]),e._v(" 修改，默认为 "),v("code",[e._v("30")]),e._v(" 秒，能进行这一步更新服务列表的前提是你要配置 "),v("code",[e._v("eureka.client.register-with-eureka=true")]),e._v(" ，这个默认值为 "),v("code",[e._v("true")]),e._v(" 。主要调用流程如下图所示：")]),e._v(" "),v("p",[v("img",{attrs:{src:"imagesureka-service-consumer-update-sequence-chart.png",alt:"eureka-service-consumer-update-sequence-chart.png"}})]),e._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),v("p",[e._v("工作中项目使用的是 "),v("code",[e._v("Spring Cloud")]),e._v(" 技术栈，它有一套非常完善的开源代码来整合 "),v("code",[e._v("Eureka")]),e._v(" ，使用起来非常方便。之前都是直接加注解和修改几个配置属性一气呵成的，没有深入了解过源码实现，本文主要是阐述了服务注册、服务发现等相关过程和实现方式，对 "),v("code",[e._v("Eureka")]),e._v(" 服务发现组件有了更近一步的了解。")]),e._v(" "),v("hr"),e._v(" "),v("p",[e._v("参考文章")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://github.com/Netflix/eureka",target:"_blank",rel:"noopener noreferrer"}},[e._v("Netflix Eureka"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("a",{attrs:{href:"https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture",target:"_blank",rel:"noopener noreferrer"}},[e._v("Service Discovery in a Microservices Architecture"),v("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=t.exports}}]);