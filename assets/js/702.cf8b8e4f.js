(window.webpackJsonp=window.webpackJsonp||[]).push([[702],{1289:function(t,a,r){"use strict";r.r(a);var e=r(2),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"线程模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程模型"}},[t._v("#")]),t._v(" 线程模型")]),t._v(" "),r("h4",{attrs:{id:"线程模型基本介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程模型基本介绍"}},[t._v("#")]),t._v(" 线程模型基本介绍")]),t._v(" "),r("p",[t._v("不同的线程模型对性能影响很大，目前存在的线程模型有：")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("传统阻塞I/O服务模型")])]),t._v(" "),r("li",[r("p",[t._v("Reactor模型")]),t._v(" "),r("p",[t._v("根据Reactor的数量和处理资源池线程的数量不同，可以分为3种")]),t._v(" "),r("ul",[r("li",[t._v("单Reactor单线程")]),t._v(" "),r("li",[t._v("单Reactor多线程")]),t._v(" "),r("li",[t._v("多Reactor多线程")])])])]),t._v(" "),r("h4",{attrs:{id:"传统阻塞i-o服务模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#传统阻塞i-o服务模型"}},[t._v("#")]),t._v(" 传统阻塞I/O服务模型")]),t._v(" "),r("p",[t._v("采用阻塞I/O模式获取输入的数据，每个连接都需要独立的线程完成数据的输入，业务处理和数据返回工作。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://img1.terwer.space/image-20220419161322076.png",alt:"image-20220419161322076"}})]),t._v(" "),r("p",[t._v("存在的问题：")]),t._v(" "),r("ol",[r("li",[t._v("当并发数很大时，会创建大量线程，占用系统资源。")]),t._v(" "),r("li",[t._v("连接创建后，如果当前线程没有数据可读，该线程会阻塞在read操作，造成线程资源浪费")])])])}),[],!1,null,null,null);a.default=v.exports}}]);